/**
 *@Name Apex Docgen
 *@Author Kenji776
 *@Description script for automatically generating code documentation from apex classes. I realize it's not the best written thing and it ends up in callback hell a little bit but since its a totally
 * linear script and the nesting doesn't go too deep I think its ok for now. Should refactor with promises later.
 */
const configFile = 'config.json';
const fs = require('fs');
const path = require('path')
const {
    exec
} = require("child_process");
const {
    promisify
} = require('util');
const {
    resolve
} = require('path');
const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);

let config = [];
const date = new Date();
const dateString = (date.getMonth() + 1) + '_' + date.getDate() + '_' + date.getFullYear();

/**
* @Description Main program body. Invokes all the other functions needed to load configs, copy source code files into working directory, convert them into markdown, then convert that into HTML, process and fix the resulting
* HTML, create a distributable zip file from the files and write the log files.
* @Return void
*/
async function init() {
    log('                                    Apex DocGen 2.0!\r\n', true, 'green');

    log('Started process at ' + date.toLocaleString(), false);

	//load all our configs into memory
    loadConfig(configFile);

	//ensure all required folders exist.
	createFolders();

    importFilesFromJson(config.source, config.files);

    //create our markdown files from the apex classes.
    generateMarkdown(config.inputDir, config.workingDir+'\\markdown', function(error, stdout, stderr) {
        log(stdout);
        log('Generated Markdown files!');


        generateHTML(config.workingDir + '\\markdown', function(complete) {
            console.log('Markdown to HTML Complete');

			//copy all the html files that have now been generated from the markdown folder into the html folder.
            copyRecursiveSync(config.workingDir + '\\markdown', config.workingDir + '\\html', ['html'], true);

			//the HTML generated by the markdown-to-html contains invalid links and needs to be updated for the styles to properly apply to process the files now.
            fixHtml(config.workingDir + '\\html');

            //create the zip file name
            let zipFileName = config.projectName + ' ' + dateString;

            //create the zip file.
            zipOutput(config.workingDir, config.outputDir, zipFileName);

            generateFileJson();
        });
    });
}

/**
* @Description creates the required folder structure if it does not exist.
* @Return void
*/
function createFolders(){
    //create needed directories
    if (!fs.existsSync(config.workingDir)) fs.mkdirSync(config.workingDir);
    if (!fs.existsSync(config.workingDir + '/markdown')) fs.mkdirSync(config.workingDir + '/markdown');
    if (!fs.existsSync(config.workingDir + '/html')) fs.mkdirSync(config.workingDir + '/html');
    if (!fs.existsSync(config.outputDir)) fs.mkdirSync(config.outputDir);
	//if (!fs.existsSync(config.workingDir + 'html/themes')) fs.mkdirSync(config.workingDir + '/html/themes');

	//copy all the themes from the source folder into the HTML themes folder
	copyRecursiveSync('themes', config.workingDir + '\\html\\themes', ['css'], false);

    //fs.copyFileSync(`themes\\${config.theme+'.css'}`, config.workingDir + '\\html\\styles.css');

    //create input directory if it doesn't exist
    if (!fs.existsSync(config.inputDir)) {
        fs.mkdirSync(config.inputDir);
        log('Input folder not found. Will not be able to automatically read input files. Will default to reading from config.json files array instead if available', true, 'yellow');
    }
}

/**
* @Description Reads configuration information from the config json file and stores it in the config global variable.
* @Param configFileName a string of the fileName to load the configuration information from.
* @Return void
*/
function loadConfig(configFileName) {
    log('Loading Configs', true);

    const configJSON = fs.readFileSync(configFileName, 'utf-8', function(err) {
        log('Config file not found or unreadable. Skipping import' + err.message, true, 'yellow');

        if (err) throw err;
    });

    config = JSON.parse(configJSON);
}

/**
 * @Description Creates markdown files by using the apexdocs-generate utility for all the files in in the sourceDir directory and writes them to the targetDir directory.
 * @Param sourceDir source directory that contains files to process
 * @Param targetDir target directory to write generated markdown files into
 * @Param callback the function to call when processing of files is done.
 */
function generateMarkdown(sourceDir, targetDir, callback) {

    log('Generating Markdown files', true);

    runCommand(`apexdocs-generate -s ${sourceDir} -t ${targetDir} -r --scope public global namespaceaccessible -g ${config.markdownGenerator}`, function(error, stdout, stderr) {
        log('Markdown files generated successfully', true);
        callback(error, stdout, stderr);
    });
}

/**
 * @Description Reads all the files in the local input folder and writes them into the config json.
 */
function generateFileJson() {
    const filesArray = fs.readdirSync(config.inputDir);

    if (filesArray.length == 0) {
        log('No files found in input directory. Not generating import JSON file.', true, 'yellow');
        return;
    }

    config.files = filesArray;

    fs.writeFileSync(configFile, JSON.stringify(config, null, 5), function(err) {
        if (err) throw err;

        log('Wrote Import JSON Files File (' + configFile + ')');
    });
}

/**
 * @Description Reads all the given files from the source folder into the local input folder.
 * @Param sourceFolder the full path on the system to read files from
 * @Param files the names of all the files to copy
 */
function importFilesFromJson(sourceFolder, files) {

    log('Reading files for import from ' + configFile);

    if (!fs.existsSync(sourceFolder)) {
        log('Source Directory "' + sourceFolder + '" could not be found. Will not be able to copy newest files. Using what is stored in folder "' + config.inputDir + '".', true, 'red');
        return;
    }

    try {
        if (!config.files || config.files.length == 0) {
            log('No importable files found in file. Skipping import', true, 'yellow');
            return;
        }

        for (const fileName of files) {
            let filePath = sourceFolder + '\\' + fileName;

            log('Copying ' + filePath);
            try {
                fs.copyFileSync(filePath, config.inputDir + '\\' + fileName);
                log('File copied!', true)
            } catch (ex) {
                log('Could not copy file ' + filePath + ' to ' + config.inputDir + '. ' + ex.message, true, 'red');
            }
        }
    } catch (ex) {
        console.log('Unable to copy files from ' + configFile);
        console.log(ex);
    }
}


/**
 * @Description Generates HTML files for all markdown files in the given folder.
 * @Param directory the folder to find markdown files in.
 * @Param callback function to call when all processing is complete
 * @Return void. Use callback instead.
 */
function generateHTML(directory, callback) {

    log('Generating HTML files!');
    let files = getFilesRecursively(directory);

    var numFiles = files.length;

    log('Found ' + numFiles + ' files to generate HTML for');

    convertMarkdownToHtml(files, function(success) {
        log('HTML Generation Done');
        if (callback) callback(true);
    });
}
/**
 * @Description Generates HTML files from all given markdown files.
 * @Param files list of all files to potentially generate HTML from 
 * @Param callback function to call when all processing is complete
 * @Param fileIndex internal tracking for what file to evaluate. Do not set.
 * @Return void. Use callback instead. Callback returns true value.
 */
function convertMarkdownToHtml(files, callback, fileIndex) {

    if (!fileIndex) fileIndex = 0;
    if (fileIndex > files.length) {
        callback(null);
    } else {
        const fileName = files[fileIndex];
        const fileNameParts = fileName.split('.');
        const fileNameNoExt = fileNameParts[0];
        const fileExt = fileNameParts[1];

        if (fileExt == 'md') {

            runCommand(`markdown ${fileName} >${fileNameNoExt}.html --flavor markdown --highlight true --stylesheet ${config.theme}.css`, function(error, stdout, stderr) {
                fileIndex++;
                if (fileIndex < files.length) convertMarkdownToHtml(files, callback, fileIndex);
                else callback(true);
            });
        } else {
            fileIndex++;
            if (fileIndex < files.length) convertMarkdownToHtml(files, callback, fileIndex);
            else callback(true);
        }
    }
}

/**
* @Description zips all the files in the working directory and saves the result to the output directory.
* @Param sourceDirectory a string of the source directory to zip all files in
* @Param targetDirectory a string of the target directory to write the created zip file into.
* @Param a string to use as the name of the zip file.
* @Return void
*/
function zipOutput(sourceDirectory, targetDirectory, fileName) {
    log('Zipping files!');

    runCommand(`7z a "${targetDirectory}/${fileName}.zip" "${sourceDirectory}/*" -r -tzip`, function(error, stdout, stderr) {
        log('Created Zip Archive!');
    });
}

/**
* @Description modifies all the markdown files in the markdown folder to fix the links as well as modify the HTML to inject the stylesheet chooser and fix other small errors/issues with the generated HTML.
* @Param sourceDirectory a string of the source directory to evaluate all HTML files in
* @Param sourceType For all links that point to this file extensions, change them to the targetType type. Ex change all links that point to '.md' files to '.html' files which is needed after conversion from markdown to html.
* @Param targetType the file of file extension to change all the sourceType links to.
* @Return void
*/
function fixHtml(directory) {
    let filesToModify = getFilesRecursively(directory, ['html']);

    log('Fixing HTML files');

	let styleSelectHtml = injectStylePicker(config.theme);

    for (const fileName of filesToModify) {

        log('Processing HTML in file: ' + fileName);
        let fileContents = fs.readFileSync(fileName, 'utf-8', function(err) {
            log('Unable to read file ' + fileName, true, 'yellow');
            if (err) throw err;
        });

        newFile = fileContents.replaceAll('.md', '.html');
        newFile = newFile.replaceAll('<body>', `<body><link rel="stylesheet" type="text/css" href="${config.theme}.css" id="_theme"><div id="_html" class="markdown-body">` + styleSelectHtml);
        newFile = newFile.replaceAll('</body>', '</div></body>')
        newFile = newFile.replaceAll('<h2 id="layout-default">layout: default</h2>', '');
        newFile = newFile.replaceAll('href="/', 'href="');
        newFile = newFile.replaceAll('|Param|Description|', 'Param ');
        newFile = newFile.replaceAll('|---|---|', '');
        newFile = unescapeHTML(newFile);
		
        fs.writeFileSync(fileName, newFile, function(err) {
            if (err) throw err;
            log('Error writting fixed html');
        });


    }
    log('HTML fixed');
}

/**
* @Description Generates the HTML to inject into each of the generated HTML pages that allows the user to select which style they would like to use. It does this by iterating over
* all the css files in the themes directory. Since the HTML files will not know where the themes directory is (they may be anywhere lower in the directory structure) and there is 
* no absolute path since these documents may be moved between different computers the approach is to read the current file path from the href and check it folder by folder for the
* 'themes' folder that contains the defaultStyle css file. It will attempt to do this starting from the 3rd folder (EX C:/users/apexDoc/docs/index.html would start at apexDoc) and 
* then sequentially check each folder until the theme is found or the path is exhaused.
* In the future will also inject a cookie to remember users preferences. Also may update to include the JS in a seperate JS file to reduce duplication. 
* @Param defaultStyle Name of css file to use as the selected default.
* @Return void
*/
function injectStylePicker(defaultStyle){

	defaultStyle += '.css';
	let themes = getFilesRecursively(config.workingDir+'\\html\\themes', ['css']);
	let themeString = '';

	themes.forEach((themeFile) => {
		var themeNameParts = themeFile.split('\\');
		var themeFileName = themeNameParts[themeNameParts.length-1];
		var themeName = themeFileName.split('.')[0];

		themeString += `<option value="${themeFileName}">${themeName}</option>`
	});

	const injectHtml = `
		<script>
		let folderIndex = 3;
		let urlParts = window.location.href.split('/');
		let cssPath;
		let currentUrl = urlParts[0];
		let loadMisses = 0;
		function setCssPath(src){
			src = src.replace('${defaultStyle}','');
			cssPath = src;

			const styleChooser = document.getElementById('styleChooser');
			styleChooser.style.display = 'block';

			const styleLoader = document.getElementById('styleLoader');
			styleLoader.style.display = 'none';

			var sel = document.getElementById('style_select').value = '${defaultStyle}';
			changeSheet('${defaultStyle}');
		}
		function handleLoadMiss(src){
			loadMisses++;
			if(loadMisses >= urlParts.length){
				const styleLoaderError = document.getElementById('styleLoadError');
				styleLoaderError.style.display = 'block';				
			}
		}

		while(folderIndex<urlParts.length){
			currentUrl +='/'+ urlParts[folderIndex];
			let el=document.createElement('script');
			el.id="sheet"+folderIndex;
			el.src=currentUrl+'/themes/${defaultStyle}';
			el.onload=function(){if(el.onload)setCssPath(this.src)}
			el.onerror=function(){if(el.onerror)handleLoadMiss(this.src)}
			document.body.appendChild(el);
			folderIndex++;
		}

		function handleStyleSelectChange(selectObject){
			 changeSheet(selectObject.value)
		}
		function changeSheet(sheetName){
			[...document.getElementsByTagName("link")].forEach((rel) => {
				rel.setAttribute("href", cssPath+'/'+sheetName);  
			});
		}
		</script>

		<div style="float:right" id="styleLoader">
			<b>Finding Styles. Please Wait</b>
		</div>
		<div style="float:right; display:none" id="styleLoadError">
			<b>Styles could not be found. Please ensure 'themes' folder exists in your documentation folder root.</b>
		</div>		
		<div style="float:right; display:none" id="styleChooser">
			<label for="style_select"> Select Style </label>
			<select onchange=handleStyleSelectChange(this) id="style_select">
				${themeString}
			</select>
		</div>	
	`;
	return injectHtml;
}


/**
 * @Description converts safe html entities &lt; &gt; &amp; in a string to < > & so they can be properly rendered in the browser.
 * @param string escapedHTML 
 * @Return string with characters converted to unescaped versions.
 */
function unescapeHTML(escapedHTML) {
    return escapedHTML.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');
}

/**
* @Description Gets all files from a directory tree recursively.
* @Param directory the root directory to look for files in
* @Param files internal variable passed to each call of itself. Do not set, or set to empty array.
* @Return an array of complete file paths for all files in the directory.
*/
function copyRecursiveSync(src, dest, fileTypes, deleteSource) {
    var exists = fs.existsSync(src);
    var stats = exists && fs.statSync(src);
    var isDirectory = exists && stats.isDirectory();
	var filePathParts = src.split('.');
	var fileExtension = filePathParts[filePathParts.length-1];
    if (isDirectory) {
        if (!fs.existsSync(dest)) fs.mkdirSync(dest);
        fs.readdirSync(src).forEach(function(childItemName) {
            copyRecursiveSync(path.join(src, childItemName),
                path.join(dest, childItemName),
				fileTypes,
				deleteSource);
        });
    } else if(!fileTypes || fileTypes.includes(fileExtension)){
		
        fs.copyFileSync(src, dest);

		if(deleteSource) fs.unlinkSync(src);
    }
};

/**
 * @Description Gets all files from a directory tree recursively.
 * @Param directory the root directory to look for files in
 * @Param files internal variable passed to each call of itself. Do not set, or set to empty array.
 * @Return an array of complete file paths for all files in the directory.
 */
function getFilesRecursively(directory, fileTypes, files) {

	console.log('Getting files recursively with types...');
	console.log(fileTypes);
    if (!files) files = [];
    fs.readdirSync(directory).forEach(File => {
        const absolute = path.join(directory, File);
		var filePathParts = File.split('.');
		var fileExtension = filePathParts[filePathParts.length-1];

		console.log('Looking at file for listint: ' + File + ' Extension: '+ fileExtension);

        if (fs.statSync(absolute).isDirectory()) return getFilesRecursively(absolute, fileTypes, files);
        else if(!fileTypes || fileTypes.includes(fileExtension)){
			
            files.push(absolute);
        }
    });

	console.log('Returning found files');
	console.log(files);
    return files;
}

/**
 * @Description Runs on complete. Makes final log entry and exits process.
 */
function finish() {
    log('Process completed', true, 'yellow');
    log('\r\n\r\n------------------------------------------------ ', false);
    process.exit(1);
}

/**
 * @Description Executes a child process on the OS
 * @Param command a command string to pass into the system shell
 * @Param callback function to call when all processing is complete
 * @Return void. Use callback instead.
 */
function runCommand(command, callback) {
    log('Running command: ' + command);
    exec(command, (error, stdout, stderr) => {
        if (error) {
            log('error: ' + error.message, true, 'red');
        }
        if (callback) callback(error, stdout, stderr);
    });
}

/**
 * @Description Creates a log entry to the log file and optionally the screen
 * @Param logItem the value to log
 * @Param printToScreen boolean flag of whether to show the log item in the console or not.
 * @Param color optional string that indicates what color to print the text to the screen in. Options are red, green, yellow.
 * @Return void. Use callback instead.
 */
function log(logItem, printToScreen, color) {
    printToScreen = printToScreen != null ? printToScreen : true;
    var colorCode = '';
    switch (color) {
        case 'red':
            colorCode = '\x1b[31m'
            break;
        case 'green':
            colorCode = '\x1b[32m';
            break;
        case 'yellow':
            colorCode = '\x1b[33m';
    }

    if (printToScreen) console.log(colorCode + '' + logItem + '\x1b[0m');

    fs.appendFile('log.txt', logItem + '\r\n', function(err) {
        if (err) throw err;
    });


}

/**
* @Description Global error handler
*/
process.on('uncaughtException', (err) => {
    log(err, true, 'red');
    process.exit(1) //mandatory (as per the Node docs)
})

init();